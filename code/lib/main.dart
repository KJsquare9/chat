import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:firebase_core/firebase_core.dart'; // Firebase Core
import 'package:firebase_messaging/firebase_messaging.dart'; // Firebase Messaging
import 'package:flutter_local_notifications/flutter_local_notifications.dart'; // Local Notifications
import 'dart:developer'; // Import the logger
import 'package:provider/provider.dart';
import 'providers/chat_service_provider.dart';
import 'services/firebase_messaging_service.dart'; // Add this import
import 'screens/news_feed_screen.dart';
import 'screens/login_screen.dart';
import 'firebase_options.dart'; // Generated by flutterfire configure
import 'services/api_service.dart'; // Import the ApiService class

// --- Background Message Handler ---
// MUST be a top-level function (not inside a class)
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // IMPORTANT: Needs its own initialization within this background isolate.
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  log("--- Background Message Handler ---");
  log("Handling a background message: ${message.messageId}");
  log("Message data: ${message.data}");
  if (message.notification != null) {
    log(
      "Message also contained a notification: ${message.notification?.title}",
    );
    // You could potentially show a local notification here if you want custom handling
    // or perform background data processing based on message.data
  }
}

// --- Setup for flutter_local_notifications ---
// 1. Create a global instance
final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
    FlutterLocalNotificationsPlugin();

// 2. Define the Android Notification Channel (Needs to match backend)
const AndroidNotificationChannel channel = AndroidNotificationChannel(
  'new_messages_channel', // ID from backend payload (android.notification.channelId)
  'New Messages', // Title shown in Android system settings
  description: 'Notifications for new chat messages.', // Description shown
  importance: Importance.high,
  playSound: true,
);

// 3. Function to initialize local notifications settings
Future<void> setupFlutterNotifications() async {
  // Create the Android Notification Channel.
  await flutterLocalNotificationsPlugin
      .resolvePlatformSpecificImplementation<
        AndroidFlutterLocalNotificationsPlugin
      >()
      ?.createNotificationChannel(channel);

  // Initialize settings for iOS/Android
  const AndroidInitializationSettings initializationSettingsAndroid =
      AndroidInitializationSettings('@mipmap/ic_launcher'); // Default icon
  final DarwinInitializationSettings initializationSettingsIOS =
      DarwinInitializationSettings(
        requestAlertPermission:
            false, // Permissions requested via FirebaseMessaging
        requestBadgePermission: false,
        requestSoundPermission: false,
      );
  final InitializationSettings initializationSettings = InitializationSettings(
    android: initializationSettingsAndroid,
    iOS: initializationSettingsIOS,
  );
  await flutterLocalNotificationsPlugin.initialize(
    initializationSettings,
    // Handler for when a notification is tapped WHILE the app is open (foreground or background)
    onDidReceiveNotificationResponse: onDidReceiveLocalNotificationResponse,
    // Handler for when a notification is tapped WHILE the app is terminated (background specific version)
    onDidReceiveBackgroundNotificationResponse:
        onDidReceiveBackgroundNotificationResponse,
  );

  // Optional: Request iOS foreground notification permissions specifically for flutter_local_notifications
  // Note: FirebaseMessaging.requestPermission already covers general alert/badge/sound
  await flutterLocalNotificationsPlugin
      .resolvePlatformSpecificImplementation<
        IOSFlutterLocalNotificationsPlugin
      >()
      ?.requestPermissions(alert: true, badge: true, sound: true);
}

// 4. Handler for tapping a local notification (Foreground/Background)
void onDidReceiveLocalNotificationResponse(
  NotificationResponse notificationResponse,
) {
  final String? payload =
      notificationResponse.payload; // Payload set when showing notification
  log('--- Local Notification Tapped ---');
  log('Payload: $payload');
  if (payload != null && payload.isNotEmpty) {
    // TODO: Implement navigation based on the payload
    // Example: Navigate to a specific chat screen if payload contains conversationId
    // Use a GlobalKey<NavigatorState> or a dedicated navigation service
    // navigatorKey.currentState?.pushNamed('/chat', arguments: {'conversationId': payload});
    log("Navigate logic to be implemented for payload: $payload");
  }
}

// 5. Handler for tapping a background local notification (Terminated/Background)
// Needs to be static or top-level
@pragma('vm:entry-point')
void onDidReceiveBackgroundNotificationResponse(
  NotificationResponse notificationResponse,
) {
  final String? payload = notificationResponse.payload;
  log('--- Background Local Notification Tapped ---');
  log('Payload: $payload');
  // You usually can't navigate directly here as the UI isn't fully initialized yet.
  // Store the payload or relevant data (e.g., in SharedPreferences) to be checked
  // when the app fully launches.
}

// --- Global Functions for Notification Permissions ---
// Request notification permissions from the user
Future<void> requestNotificationPermissions() async {
  FirebaseMessaging messaging = FirebaseMessaging.instance;
  NotificationSettings settings = await messaging.requestPermission(
    alert: true,
    announcement: false,
    badge: true,
    carPlay: false,
    criticalAlert: false,
    provisional:
        false, // Set to true for provisional authorization on iOS (notifications delivered quietly initially)
    sound: true,
  );
  if (settings.authorizationStatus == AuthorizationStatus.authorized) {
    log('User granted permission');
    // Get token now that permission is granted
    await getAndSendFCMToken();
  } else if (settings.authorizationStatus == AuthorizationStatus.provisional) {
    log('User granted provisional permission');
    await getAndSendFCMToken();
  } else {
    log('User declined or has not accepted permission');
    // Update user preferences in the database
    await updateNotificationPreference(false);
  }
}

// Get FCM token and send it to the backend
Future<void> getAndSendFCMToken() async {
  try {
    // For Apple Push Notification service (APNs) tokens on iOS and macOS
    String? apnsToken = await FirebaseMessaging.instance.getAPNSToken();
    if (apnsToken != null) {
      log("APNS Token: $apnsToken");
      // You generally don't send the APNS token directly to your backend
      // FCM handles the translation using the FCM token.
    }

    // Get the FCM token
    String? token = await FirebaseMessaging.instance.getToken();
    if (token != null) {
      log('FCM Token: $token');
      // Send token to backend and update user preferences
      await updateNotificationPreference(true, token: token);

      // Listen for token refreshes (tokens can change!)
      FirebaseMessaging.instance.onTokenRefresh
          .listen((newToken) {
            log("FCM Token Refreshed: $newToken");
            updateNotificationPreference(true, token: newToken);
          })
          .onError((err) {
            log("Error listening to token refresh: $err");
          });
    } else {
      log("Failed to get FCM token.");
    }
  } catch (e) {
    log('Error getting/sending FCM token: $e');
  }
}

// Update user notification preferences in the backend
Future<void> updateNotificationPreference(bool allow, {String? token}) async {
  try {
    final prefs = await SharedPreferences.getInstance();
    final userId = prefs.getString('userId');
    if (userId != null) {
      final ApiService apiService = ApiService();
      await apiService.updateNotificationPreference(userId, allow, token);
    }
  } catch (e) {
    log('Error updating notification preference: $e');
  }
}

// --- Main Application Entry Point ---
final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

void main() async {
  // 1. Ensure Flutter framework is ready
  WidgetsFlutterBinding.ensureInitialized();

  // 2. Initialize Firebase
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

  // 3. Set the background message handler
  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);

  // 4. Setup local notifications (for foreground display)
  await setupFlutterNotifications();

  // 5. Check login status (Your existing logic)
  final prefs = await SharedPreferences.getInstance();
  final token = prefs.getString('token');

  // 6. Run the app
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(
          create: (_) => ChatServiceProvider(),
        ), // Change from ChatService to ChatServiceProvider
        // Add other providers here if needed
      ],
      child: MyApp(isLoggedIn: token != null),
    ),
  );
}

// --- Your Existing MyApp Widget ---
class MyApp extends StatefulWidget {
  final bool isLoggedIn;
  const MyApp({super.key, required this.isLoggedIn});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  final FirebaseMessagingService _firebaseMessaging =
      FirebaseMessagingService();

  @override
  void initState() {
    super.initState();
    if (widget.isLoggedIn) {
      _firebaseMessaging.initialize();

      // Initialize chat service by loading current user ID
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Provider.of<ChatServiceProvider>(
          context,
          listen: false,
        ).loadCurrentUserId();
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      navigatorKey: navigatorKey, // Add this key for notification navigation
      debugShowCheckedModeBanner: false,
      home: widget.isLoggedIn ? const NewsFeedScreen() : const LoginScreen(),
    );
  }
}
